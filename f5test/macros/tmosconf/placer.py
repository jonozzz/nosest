#!/usr/bin/env python
'''
Created on Apr 17, 2013

@author: jono
'''

from f5test.macros.base import Macro
from f5test.interfaces.ssh import SSHInterface
from f5test.interfaces.config import ConfigInterface
from f5test.interfaces.rest.irack import IrackInterface
from f5test.interfaces.rest.emapi import EmapiInterface
from f5test.interfaces.rest.emapi.objects import EasySetup
from f5test.interfaces.rest.emapi.objects.shared import SystemSetup, Echo, SystemStarted
from f5test.commands.rest.device import DEFAULT_ALLBIGIQS_GROUP, DEFAULT_OR_PEERS_GROUP
from f5test.commands.rest import biqmgmtcm as BIGIQCM
from f5test.interfaces.rest.emapi.objects import NetworkDiscover, DeviceResolver
from f5test.interfaces.rest.core import AUTH

from f5test.macros.tmosconf.scaffolding import Partition, Mirror, enumerate_stamps,\
    FileStamp
from f5test.macros.tmosconf.base import (SystemConfig, NetworkConfig)
from f5test.macros.tmosconf.canned.ltm import LTMConfig
from f5test.macros.tmosconf.net import SelfIP
import f5test.commands.shell as SCMD
from f5test.utils.net import ip4to6
from f5test.utils.wait import wait_args, wait
from f5test.macros.webcert import WebCert
from f5test.macros.keyswap import KeySwap
from f5test.base import Options as O
from f5test.defaults import ROOT_USERNAME, ROOT_PASSWORD
from netaddr import IPAddress, IPNetwork
from f5test.commands.shell import WIPE_STORAGE
import logging
import re
import sys
import os
import csv
import datetime
import time
#import itertools
from f5test.commands.shell.base import SSHCommandError
#from f5test.macros.tmosconf.sys import SSLKey, SSLCert
from f5test.interfaces.rest.emapi.objects.bigip import AuthzRoles

__version__ = 2.0

DEFAULT_NODES = 10
DEFAULT_NODE_START = '10.10.0.50'
DEFAULT_POOLS = 60
DEFAULT_MEMBERS = 1
DEFAULT_VIPS = 8
DEFAULT_PARTITIONS = 0
DEFAULT_ROOT_USERNAME = ROOT_USERNAME
DEFAULT_ROOT_PASSWORD = ROOT_PASSWORD
DEFAULT_TIMEOUT = 180
DEFAULT_SELF_PREFIX = 16
SCF_FILENAME = '/tmp/config.scf'
DNS_SERVERS = ['172.27.1.1']
DNS_SUFFIXES = ['mgmt.pdsea.f5net.com', 'f5net.com']
NTP_SERVERS = ['ntp.f5net.com']
OUR_ADMIN_USERNAME = OUR_ADMIN_PASSWORD = 'a'
BIQ_STORAGE_MASTER_KEY = "A5bcde02!A5bcde02!"
HEADER = """# Autogenerated by tmosconf %s\n\n""" % __version__
LOG = logging.getLogger(__name__)

SUBNET_MAP = dict([(y, x) for x, y in enumerate(('172.27.27.0/24',))])


class ConfigPlacer(Macro):
    SystemConfig = SystemConfig
    NetworkConfig = NetworkConfig
    LTMConfig = LTMConfig

    def __init__(self, options, address=None, *args, **kwargs):
        self.context = O()
        self.options = O(options)

        if options.verbose:
            level = logging.DEBUG
        else:
            level = logging.INFO
            # Shut paramiko's mouth
            logging.getLogger('paramiko.transport').setLevel(logging.ERROR)
            logging.getLogger('f5test').setLevel(logging.ERROR)
            logging.getLogger('f5test.macros').setLevel(logging.INFO)

        LOG.setLevel(level)
        logging.basicConfig(level=level)

        self.options.setifnone('node_count', DEFAULT_NODES)
        self.options.setifnone('pool_count', DEFAULT_POOLS)
        self.options.setifnone('pool_members', DEFAULT_MEMBERS)
        self.options.setifnone('vip_count', DEFAULT_VIPS)
        self.options.setifnone('node_start', DEFAULT_NODE_START)
        self.options.setifnone('partitions', DEFAULT_PARTITIONS)
        self.options.setifnone('timeout', DEFAULT_TIMEOUT)
        self.options.setifnone('bigiq_storage_master_key',
                               BIQ_STORAGE_MASTER_KEY)

        if self.options.device:
            self.device = ConfigInterface().get_device(options.device)
            self.address = self.device.address
        else:
            self.device = None
            self.address = address
            self.options.setifnone('username', DEFAULT_ROOT_USERNAME)
            self.options.setifnone('password', DEFAULT_ROOT_PASSWORD)

        # can.* shortcuts to check for certain features based on the version
        self.can = O()

        def can_tmsh(v):
            return (v.product.is_bigip and v >= 'bigip 11.0.0' or
                    v.product.is_em and v >= 'em 2.0.0' or
                    v.product.is_bigiq or
                    v.product.is_iworkflow)
        self.can.tmsh = can_tmsh

        def can_provision(v):
            return (v.product.is_bigip and v >= 'bigip 10.0.1' or
                    v.product.is_em and v >= 'em 2.0.0' or
                    v.product.is_bigiq or
                    v.product.is_iworkflow)
        self.can.provision = can_provision

        def can_lvm(sshifc):
            return not sshifc('/usr/lib/install/lvmtest').status
        self.can.lvm = can_lvm

        self.has = O()

        def has_asm(s):
            return bool(SCMD.tmsh.get_provision(ifc=s).asm)
        self.has.asm = has_asm

        def has_lvm(s):
            return not s('/usr/lib/install/lvmtest').status
        self.has.lvm = has_lvm

        super(ConfigPlacer, self).__init__(*args, **kwargs)

    def csv_provider(self, mgmtip, csv_rpath=None):
        """
        Get the static data for a device with a given mgmtip from a CSV file.
        """
        venv_path = os.environ['VIRTUAL_ENV']
        csv_rel = csv_rpath or self.options.csv
        csv_location = venv_path + csv_rel

        data = O()
        with open(csv_location, 'rb') as csvfile:
            reader = csv.DictReader(csvfile)

            device_row = None
            for row in reader:
                # Clean up whitespaces
                row = {x.strip(): y.strip() for x, y in row.items()}
                if IPAddress(mgmtip) == IPNetwork(row['mgmtip']).ip:
                    device_row = row
                    break

            if device_row:
                if 'hostname' in device_row and device_row['hostname']:
                    data.hostname = device_row['hostname']

                data.licenses = {}
                if 'reg_key' in device_row and device_row['reg_key']:
                    data.licenses.reg_key = [device_row['reg_key']]

                data.selfip = {}
                if 'internal' in device_row and device_row['internal']:
                    data.selfip.internal = IPNetwork(device_row['internal'])
                if 'external' in device_row and device_row['external']:
                    data.selfip.external = IPNetwork(device_row['external'])

                if 'gateway' in device_row and device_row['gateway']:
                    data.gateway = IPAddress(device_row['gateway'])

                data.mgmtip = IPNetwork(device_row['mgmtip'])

            else:
                LOG.warning("No devices with mgmtip=%s found in CSV." % mgmtip)

            LOG.debug(data)
            return data

    def irack_provider(self, address, username, apikey, mgmtip, timeout=120):
        """Get the static data for a device with a given mgmtip from iRack."""
        data = O()
        with IrackInterface(address=address,
                            timeout=timeout,
                            username=username,
                            password=apikey, proto='http') as irack:
            params = dict(address_set__address__in=mgmtip, address_set__type=4)
            # Locate the static bag for the F5Asset with mgmtip
            ret = irack.api.staticbag.filter(asset__type=1, **params)

            if ret.data.meta.total_count == 0:
                LOG.warning("No devices with mgmtip=%s found in iRack." % mgmtip)
                return data
            if ret.data.meta.total_count > 1:
                raise ValueError("More than one device with mgmtip=%s found in iRack." % mgmtip)

            bag = ret.data.objects[0]
            bagid = bag['id']

            # Get the hostname
            ret = irack.api.staticsystem.filter(bag=bagid)
            assert ret.data.meta.total_count == 1, "No StaticSystem entries for bagid=%s" % bagid
            data.hostname = ret.data.objects[0].hostname

            # Get all reg_keys
            ret = irack.api.staticlicense.filter(bag=bagid)
            assert ret.data.meta.total_count >= 1, "No StaticLicense entries for bagid=%s" % bagid
            data.licenses = {}
            data.licenses.reg_key = [x.reg_key for x in ret.data.objects]

            # Get all VLAN -> self IPs pairs
            ret = irack.api.staticaddress.filter(bag=bagid, type=1)
            data.selfip = {}
            for o in ret.data.objects:
                vlan = o.vlan.split('/')[-1]
                # TODO: IPv6 support...someday?
                if IPAddress(o.address).version == 4 \
                   and not int(o.floating):
                    data.selfip[vlan] = IPNetwork("{0.address}/{0.netmask}".format(o))

            # Get all mgmt ips
            ret = irack.api.staticaddress.filter(bag=bagid, type=0)
            assert ret.data.meta.total_count >= 1, "No StaticAddress entries for bagid=%s" % bagid
            data.mgmtip = {}
            for o in ret.data.objects:
                if IPAddress(o.address).version == 4:
                    data.mgmtip = IPNetwork("{0.address}/{0.netmask}".format(o))

            # GW
            ret = irack.api.staticaddress.filter(bag=bagid, type=3)
            assert ret.data.meta.total_count >= 1, "No StaticAddress entries for bagid=%s" % bagid
            for o in ret.data.objects:
                if IPAddress(o.address).version == 4:
                    data.gateway = IPAddress(o.address)

        LOG.debug(data)
        return data

    def make_context(self):
        ctx = self.context
        version_data = SCMD.ssh.get_version(ifc=self.sshifc)
        ctx.version = version_data
        ctx.project = SCMD.ssh.parse_keyvalue_file('/VERSION',
                                                   ifc=self.sshifc).get('project')
        ctx.platform = SCMD.ssh.get_platform(ifc=self.sshifc)['platform']
        ctx.is_cluster = SCMD.ssh.is_cluster(ifc=self.sshifc)
        ctx.is_vcmp = ctx.platform == 'Z101'
        ctx.status = SCMD.ssh.GetPrompt(ifc=self.sshifc)\
            .run_wait(lambda x: x not in ('INOPERATIVE',),
                      progress_cb=lambda x: 'Still %s...' % x,
                      timeout_message="Timeout ({0}s) waiting for an non-inoperative prompt.",
                      timeout=self.options.timeout)

        if self.can.provision(ctx.version):
            ctx.provision = {}
            modules = SCMD.tmsh.get_provision(ifc=self.sshifc)
            for k, v in modules.items():
                if v:
                    ctx.provision[k] = v['level']

        try:
            tokens = SCMD.ssh.parse_license(ifc=self.sshifc, tokens_only=True)
            ctx.modules = dict([(k[4:], v) for (k, v) in list(tokens.items())
                                if k.startswith('mod_')])

            ctx.features = dict([(k, v) for (k, v) in list(tokens.items())
                                if not k.startswith('mod_')])
        except SCMD.ssh.LicenseParsingError as e:
            ctx.modules = {}
            ctx.features = {}
            LOG.debug(e)
            LOG.warning('License file parsing failed. Harmless if this is a clean box.')

        LOG.info('Version: {0.product.to_tmos} {0.version} {0.build}'.format(ctx.version))
        LOG.info('Platform: %s', ctx.platform)
        LOG.info('Licensed modules: %s', ', '.join(sorted(ctx.modules)))
        if self.can.provision(ctx.version):
            LOG.info('Current provisioning: %s', ', '.join(sorted(ctx.provision)))
        return ctx

    def prep(self):
        self.sshifc = SSHInterface(device=self.device,
                                   address=self.address,
                                   username=self.options.username,
                                   password=self.options.password,
                                   timeout=self.options.timeout,
                                   port=self.options.ssh_port)
        self.sshifc.open()

    def set_networking(self, o):
        ctx = self.context
        if self.options.mgmtip:
            o.mgmtip = IPNetwork(self.options.mgmtip)
            if o.mgmtip.prefixlen == 32:
                o.mgmtip.prefixlen = 24
                LOG.warning('Assuming /24 to the management IP.')
        elif ctx.is_cluster:
            ret = SCMD.tmsh.list('sys cluster default', ifc=self.sshifc)
            o.mgmtip = IPNetwork(ret['sys cluster default']['address'])
            ret = SCMD.tmsh.list('sys management-route', ifc=self.sshifc)
            # Sometimes it's defined as "default" some other times it's "0.0.0.0"
            if ret:
                o.gateway = IPAddress(list(ret.values())[0]['gateway'])
        else:
            # Try to find the existing IP configuration on management interface.
            #ret = self.sshifc()
            ret = wait_args(self.sshifc, func_args=("ethconfig --getcurrent",),
                            condition=lambda ret: ret.stdout.split()[0] != '0.0.0.0',
                            timeout=600, interval=5,
                            timeout_message="Can't get a valid management interface address")

            bits = ret.stdout.split()
            o.mgmtip = IPNetwork("{0[0]}/{0[1]}".format(bits))
            o.gateway = IPAddress(bits[2])

        # If None or IPAddress('0.0.0.0')
        if not o.gateway:
            o.gateway = IPAddress(self.options.mgmtgw) if self.options.mgmtgw \
                else o.mgmtip.broadcast - 1

        # Preserve the DHCP flag for the management interface & hostname
        if self.can.tmsh(ctx.version):
            ret = SCMD.tmsh.list('sys db dhclient.mgmt', ifc=self.sshifc)
            o.dhcp = ret['sys db dhclient.mgmt']['value'] == 'enable'

            if not o.hostname:
                ret = SCMD.tmsh.list('sys db hostname', ifc=self.sshifc)
                if '.' not in ret['sys db hostname']['value']:
                    o.hostname = "ip-%s.%s" % (str(o.mgmtip.ip).replace('.', '-'),
                                               DNS_SUFFIXES[0])
                else:
                    o.hostname = ret['sys db hostname']['value']

    def set_provisioning(self, o):
        ctx = self.context
        if not self.can.provision(ctx.version):
            LOG.info('Provision not supported on the target')
            return

        o.provision = {}
        provision = []
        if self.options.get('provision'):
            for prov in self.options['provision'].split(','):
                if prov:
                    bits = prov.lower().split(':', 1)
                    if len(bits) > 1:
                        module, level = bits
                        assert level in ('minimum', 'nominal', 'dedicated')
                    else:
                        module = bits[0].strip()
                        if module == 'ltm':
                            level = 'nominal'
                        elif module == 'vcmp':
                            level = 'dedicated'
                        else:
                            level = 'minimum'
                    provision.append((module, level))

        if provision:
            v = ctx.version
            for module, level in provision:
                if module == 'afm' and not (v.product.is_bigip and v >= 'bigip 11.3.0'):
                    LOG.warning('AFM cannot be provisioned on this target.')
                    continue
                o.provision[module] = level
        else:
            # Preserve provisioning.
            modules = SCMD.tmsh.get_provision(ifc=self.sshifc)
            for module, level_kv in modules.items():
                if level_kv:
                    level = level_kv['level']
                    o.provision[module] = level

    def set_users(self, o):
        ctx = self.context
        v = ctx.version
        o.users = {}

        o.users[OUR_ADMIN_USERNAME] = 'admin'
        if v.product.is_bigip or v.product.is_em:
            o.users.g = 'guest'
            o.users.o = 'operator'
            o.users.ae = 'application-editor'
            o.users.m = 'manager'
            o.users.um = 'user-manager'
            o.users.ra = 'resource-admin'

        if v.product.is_bigip and v >= 'bigip 11.3.0':
            o.users.cm = 'certificate-manager'
            o.users.im = 'irule-manager'
            o.users.au = 'auditor'
            o.users.asa = 'web-application-security-administrator'
            o.users.ase = 'web-application-security-editor'
            o.users.fm = 'firewall-manager'

        if v.product.is_bigiq:
            o.users.g = 'guest'
            o.users.fw = 'firewall-manager'

    def set_vlans(self, o):
        ctx = self.context
        lacp = self.options.trunks_lacp

        if ctx.platform.startswith('A'):
            o.trunks = {}
            eth1 = 'internal'  # Trunk names
            eth2 = 'external'
        elif ctx.platform.startswith('Z'):
            # VEs can may have a variable number of TMM interfaces.
            # Adjusting accordingly.
            ret = SCMD.tmsh.list('net interface', ifc=self.sshifc)
            interfaces = sorted([x.split()[2] for x in list(ret.keys())
                                 if x.split()[2] != 'mgmt'])
            eth1, eth2 = (interfaces + [None, None])[:2]
        else:
            eth1 = '1.1'
            eth2 = '1.2'

        o.vlans = {}
        if ctx.is_vcmp:
            # No trunks. They will be automatically generated on VCMP guests.
            eth1 = eth2 = None
            ret = SCMD.tmsh.list('net vlan', ifc=self.sshifc)
            for key, obj in list(ret.items()):
                s = Mirror(key, obj)
                o.vlans[s.name] = s

        if ctx.platform == 'A100':
            o.trunks.internal = O(interfaces=['1/2.1', '2/2.1', '3/2.1', '4/2.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/2.2', '2/2.2', '3/2.2', '4/2.2'], lacp=lacp)
        elif ctx.platform in ('A107', 'A109', 'A111'):
            o.trunks.internal = O(interfaces=['1/1.1', '2/1.1', '3/1.1', '4/1.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/1.2', '2/1.2', '3/1.2', '4/1.2'], lacp=lacp)
        elif ctx.platform == 'A108':
            o.trunks.internal = O(interfaces=['1/1.1', '2/1.1', '3/1.1', '4/1.1', '5/1.1', '6/1.1', '7/1.1', '8/1.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/1.2', '2/1.2', '3/1.2', '4/1.2', '5/1.2', '6/1.2', '7/1.2', '8/1.2'], lacp=lacp)

        def parse_vlan_options(kind):
            specs = O(tagged=[], untagged=[])
            if kind == 'internal':
                tags = self.options.vlan_internal
                if not tags:
                    specs.untagged.append(eth1)
            if kind == 'external':
                tags = self.options.vlan_external
                if not tags:
                    specs.untagged.append(eth2)

            if tags:
                for tag in re.split('\s+', tags):
                    key, value = tag.split('=')
                    if key == 'tag':
                        specs.tag = value
                    else:
                        specs[key].append(value)
            return specs

        if eth1:
            alias = self.options.vlan_internal_name
            o.vlans[alias] = O(**parse_vlan_options('internal'))
        if eth2:
            alias = self.options.vlan_external_name
            o.vlans[alias] = O(**parse_vlan_options('external'))

#     def fix_cmi(self):
#         """
#         The main goal of this method is to empty all device groups, otherwise
#         the config load will fail. There should be a better way of doing this.
#         """
#         ctx = self.context
#         if self.can.tmsh(ctx.version):
#             LOG.debug('Emptying CM device groups...')
#             ret = SCMD.tmsh.list('cm device-group', ifc=self.sshifc)
#             for key, value in ret.iteritems():
#                 devices = value.get('devices')
#                 if devices:
#                     ret = self.sshifc('tmsh modify %s devices delete { %s }' %
#                                       (key, ' '.join(devices.keys())))
#                     if ret.status:
#                         LOG.warning(ret)

    def dump(self, tree, ctx, func=None):
        f = sys.stdout  # @UndefinedVariable
        LOG.info('Rendering configuration file...')
        f.write(HEADER)
        tree.render(stream=f, func=func)

    def load(self, tree, ctx, func=None):
        with self.sshifc.api.sftp().open(SCF_FILENAME, 'w') as f:
            LOG.info('Rendering configuration file...')
            f.write(HEADER)
            tree.render(stream=f, func=func)

        for stamp in enumerate_stamps(tree, FileStamp, include_common=False):
            self.sshifc('mkdir -p %s' % os.path.dirname(stamp.remote_path))
            with self.sshifc.api.sftp().open(stamp.remote_path, 'w') as f:
                LOG.info('Creating file %s...' % stamp.remote_path)
                f.write(stamp.payload)

        if self.can.tmsh(ctx.version):
            if self.options.verify:
                LOG.info('Verifying configuration...')
                ret = self.sshifc('tmsh -q load sys config file %s verify' % SCF_FILENAME)
                LOG.info(ret.stdout)
            else:
                LOG.info('Loading configuration...')
                SCMD.ssh.generic('tmsh -q load sys config file %s' % SCF_FILENAME, ifc=self.sshifc)
        else:
            LOG.info('Loading configuration...')
            SCMD.ssh.generic('b import  %s' % SCF_FILENAME, ifc=self.sshifc)

    def save(self, ctx):
        LOG.info('Saving configuration...')
        if self.can.tmsh(ctx.version):
            SCMD.ssh.generic('tmsh save sys config partitions all', ifc=self.sshifc)
        else:
            SCMD.ssh.generic('b save all', ifc=self.sshifc)

    def reset_trust(self):
        v = self.context.version
        if v.product.is_bigiq or v.product.is_iworkflow:
            return

        if self.can.tmsh(v):
            LOG.info('Resetting trust...')
            SCMD.ssh.Generic('tmsh delete cm trust-domain all', ifc=self.sshifc).\
                run_wait(lambda x: x.status == 0,
                         progress_cb=lambda x: 'delete trust-domain retry...',
                         timeout=self.options.timeout)

    def ready_wait(self):
        ctx = self.context
        if self.options.get('dry_run'):
            return

        if ctx.version >= 'bigip 13.1':
            wait(lambda: set(self.sshifc.api.run('. /usr/lib/bigstart/bigip-ready-functions && bigip_ready_get').stdout.split()),
                 condition=lambda x: x==set(['config', 'license', 'provision']),
                 timeout=300, interval=10,
                 progress_cb=lambda x: 'Output: %s' % x,
                 timeout_message="Timeout for system to get ready {0}s")
        
        LOG.info('Waiting for reconfiguration...')
        timeout = self.options.timeout
        SCMD.ssh.FileExists('/var/run/mprov.pid', ifc=self.sshifc)\
            .run_wait(lambda x: x is False,
                      progress_cb=lambda x: 'Provisioning in progress...',
                      timeout=timeout)
        if (self.can.provision(ctx.version) and self.has.asm(self.sshifc) and
                self.has.lvm(self.sshifc)):
            SCMD.ssh.FileExists('/var/lib/mysql/.moved.to.asmdbvol', ifc=self.sshifc)\
                .run_wait(lambda x: x,
                          progress_cb=lambda x: 'ASWADB still not there...',
                          timeout=timeout)
        # Wait for ASM config server to come up.
        if self.can.provision(ctx.version) and self.has.asm(self.sshifc):
            LOG.info('Waiting for ASM config server to come up...')
            SCMD.ssh.Generic(r'netstat -anp|grep -P ":9781\s+(0\.0\.0\.0|::):\*\s+LISTEN"|wc -l',
                             ifc=self.sshifc).run_wait(lambda x: int(x.stdout),
                                                       progress_cb=lambda x: 'ASM cfg server not up...',
                                                       timeout=300)

        LOG.info('Waiting for Active prompt...')
        s = SCMD.ssh.GetPrompt(ifc=self.sshifc)\
            .run_wait(lambda x: x in ('Active', 'Standby', 'ForcedOffline',
                                      'RESTART DAEMONS', 'REBOOT REQUIRED',
                                      'LICENSE EXPIRED', 'REACTIVATE LICENSE')
                                or x.startswith('Act*')
                                or x.startswith('TimeLimited'),
                      progress_cb=lambda x: 'Still not active (%s)...' % x,
                      timeout_message="Timeout ({0}s) waiting for an 'Active' prompt.",
                      timeout=timeout)

        if s == 'RESTART DAEMONS':
            LOG.info('Restarting daemons...')
            self.call('bigstart restart')
            SCMD.ssh.GetPrompt(ifc=self.sshifc)\
                .run_wait(lambda x: x in ('Active', 'Standby', 'ForcedOffline'),
                          progress_cb=lambda x: 'Still not active (%s)...' % x,
                          timeout=timeout)
        elif s == 'REBOOT REQUIRED':
            LOG.warn('A manual reboot is required.')

        if SCMD.ssh.file_exists('/var/run/grub.conf.lock', ifc=self.sshifc):
            self.ssh.api.remove('/var/run/grub.conf.lock')

    def ssh_key_exchange(self):
        if self.options.get('no_sshkey'):
            return

        o = O()
        o.device = self.device
        o.username = self.options.username
        o.password = self.options.password
        o.port = self.options.ssh_port
        cs = KeySwap(o, address=self.address)
        cs.run()

    def ssl_signedcert_install(self, hostname):
        # BUG: Sometimes user 'a' role gets downgraded to 'guest' at this point.
        #      It's still unclear why this happens.
        if self.context.version >= 'bigip 11.6' or self.context.version >= 'bigiq 5.0' or \
                self.context.version >= 'iworkflow 2.0':
            SCMD.ssh.generic('tmsh modify auth user %s partition-access modify  {all-partitions {role admin}}' % OUR_ADMIN_USERNAME,
                             ifc=self.sshifc)
        else:
            SCMD.ssh.generic('tmsh modify auth user %s role admin' % OUR_ADMIN_USERNAME,
                             ifc=self.sshifc)
        o = O()
        o.admin_username = OUR_ADMIN_USERNAME
        o.root_username = self.options.username
        o.ssh_port = self.options.ssh_port
        o.ssl_port = self.options.ssl_port
        o.verbose = self.options.verbose
        o.timeout = 300
        LOG.info('Pushing the key/certificate pair')

        # The special a:a admin user is used here. It should be included in the
        # remote_config yaml config in the users.administrator section.
        o.admin_password = OUR_ADMIN_PASSWORD
        o.root_password = self.options.password

        if hostname:
            o.alias = [hostname]
        cs = WebCert(o, address=self.address)
        cs.run()

    def bigiq_special_rest_handling(self, tree, ctx):
        """1. Setup selfips via rest api
              Because the use of tmsh has become frown upon starting with 4.2
           2. Get Past the setup screen because config is done
              Because BQ >5.0 can't acknowledge that setup is really done
           3. Wait for self device resolver
        """
        v = ctx.version
        if v.product.is_bigiq and v >= 'bigiq 4.2.0' or v.product.is_iworkflow:
            # if v < 'bigiq 5.0':
            # XXX: Because sometimes user 'a' set via tmsh is not picked up.
            LOG.info("bqsrh: in bq special handling - restarting restjavad...")
            # self.call('tmsh list auth user %s' % OUR_ADMIN_USERNAME)
            # self.call('bigstart restart restjavad')
            # BZ584041: Sometimes user 'a' role gets downgraded to 'guest' at this point.

            LOG.debug("Sleeping 10 seconds to catch the user downgrading.")
            time.sleep(10)
            ret = self.call('tmsh list auth user %s' % OUR_ADMIN_USERNAME)
            if "role admin" not in ret.stdout and v >= 'bigiq 5.0':
                LOG.error("bigiq_special_rest_handling - User a was found demoted! Retry...")
                # This does not seem to work all the time. Adding a hard sleep
                # to see if it helps.
                self.call('tmsh modify auth user %s partition-access modify  {all-partitions {role admin}}' % OUR_ADMIN_USERNAME)

            if v >= 'bigiq 5.1.0':
                try:
                    ret = self.call('set-basic-auth on')
                    LOG.info("Allow basic auth: {0}".format(ret))
                except:
                    LOG.error("Could not set to allow basic authentication (also) on this BQ DUT.")
            with EmapiInterface(username=OUR_ADMIN_USERNAME,
                                password=OUR_ADMIN_PASSWORD,
                                port=self.options.ssl_port,
                                address=self.address, auth=AUTH.BASIC) as rstifc:
                if v >= 'bigiq 4.6.0':
                    LOG.info("Wait for SystemStarted api...")
                    SystemStarted.wait(rstifc.api, timeout=240)

                # Make sure that the BIG-IQ storage master password is set
                # (if applicable), before we continue.
                if v >= 'bigiq 5.2':
                    LOG.debug("Setting the Secure Storage Master key...")
                    if BIGIQCM.storage.is_secure_storage_master_key_set(ifc=rstifc) is True:
                        LOG.debug("BIG-IQ storage master key is already set.")
                    else:
                        LOG.info("Setting the BIG-IQ storage master key...")
                        BIGIQCM.storage.set_secure_storage_master_key(passphrase=self.options['bigiq_storage_master_key'],
                                                                      ifc=rstifc)
                    # Make sure it really got enabled, since it is critical to later code.
                    BIGIQCM.storage.is_secure_storage_master_key_set(ifc=rstifc, wait_for_it=True)

                payload = O(discoveryAddress=self.address)
                wait_args(rstifc.api.put, func_args=(NetworkDiscover.URI, payload),
                          timeout=180, interval=5,
                          timeout_message="Can't put mgmtip to /mgmt/shared/identified-devices/config/discovery after {0}s")

                wait(lambda: rstifc.api.get(NetworkDiscover.URI),
                     condition=lambda ret: ret.discoveryAddress == self.address,
                     timeout=180, interval=5,
                     timeout_message="Can't get /mgmt/shared/identified-devices/config/discovery after {0}s")

                if v >= 'bigiq 5.0.0' or v >= 'iworkflow 2.0':
                    payload = SystemSetup()
                    wait_args(rstifc.api.patch, func_args=(SystemSetup.URI, payload),
                              timeout=180, interval=5,
                              timeout_message="Can't patch Shared System Setup after {0}s")
                
                if v >= 'bigiq 5.0.0':
                    payload = O(systemPersonality='big_iq')
                    rstifc.api.post('/mgmt/cm/system/provisioning', payload)
                
                payload = O(selfIpAddresses=[])
                for self_ip in enumerate_stamps(tree, SelfIP, include_common=False):
                    # XXX: BIGIQ 4.2 API only supports untagged.
                    for iface in self_ip.vlan.untagged:
                        payload.selfIpAddresses.append(O(address=str(self_ip.address),
                                                         vlan=self_ip.vlan.name,
                                                         iface=iface))
                #if v >= 'iworkflow 2.0':
                payload.dnsServerAddresses = DNS_SERVERS if self.options.dns_servers is None else \
                    self.options.dns_servers
                payload.dnsSearchDomains = DNS_SUFFIXES if self.options.dns_suffixes is None else \
                    self.options.dns_suffixes
                payload.ntpServerAddresses = NTP_SERVERS if self.options.ntp_servers is None else \
                    self.options.ntp_servers

                # Workaround for BZ607386
                if not payload.selfIpAddresses:
                    payload.pop('selfIpAddresses')

                LOG.info('Patching EasySetup with the selfips...')
                wait_args(rstifc.api.patch, func_args=(EasySetup.URI, payload),
                          timeout=180, interval=5,
                          timeout_message="Can't patch EasySetup ready after {0}s")

                LOG.info('Waiting for REST framework to come up '
                         'on BQ device: {0}...'.format(self.address))

                if v >= 'bigiq 4.6.0':
                    LOG.info("Wait for SystemStarted api...")
                    SystemStarted.wait(rstifc.api, timeout=240)
                    # LOG.info("Wait for all BP group to have BQ ...")  # BZ582456
                    # DeviceResolver.wait_for_bigiq_count(rstifc.api, BIGIP_ALLDEVICES_GROUP, count=1)

                wait_args(rstifc.api.get, func_args=[NetworkDiscover.URI],
                          timeout=60,
                          timeout_message="BQ NetworkDiscover.URI not available after {0}s")
                DeviceResolver.wait(rstifc.api, DEFAULT_OR_PEERS_GROUP if v >= 'iworkflow 2.0' else DEFAULT_ALLBIGIQS_GROUP)

    def bigip_special_rest_handling(self, tree, ctx):
        """1. Wait for a list of apis
        """
        v = ctx.version
        if v.product.is_bigip and (v >= 'bigip 11.5.1'):
            with EmapiInterface(username=OUR_ADMIN_USERNAME,
                                password=OUR_ADMIN_PASSWORD,
                                port=self.options.ssl_port, auth=AUTH.BASIC,
                                address=self.address) as rstifc:

                LOG.debug('Waiting for REST workers to come up '
                          'on BP device: {0}...'.format(self.device))

                def wait_available(uri):
                    return rstifc.api.get(uri) == {}
                if v < 'bigip 11.6.0' or v >= 'bigip 12.0.0':  # not working on 11.6.x with a different admin user than admin
                    wait_args(wait_available, func_args=[AuthzRoles.AVAILABLE_URI],
                              timeout=240, interval=10,
                              timeout_message="BP AuthzRoles.AVAILABLE_URI not available after {0}s")
                    wait_args(wait_available, func_args=[Echo.AVAILABLE_URI],
                              timeout=240, interval=10,
                              timeout_message="BP Echo.AVAILABLE_URI not available after {0}s")
                    wait_args(rstifc.api.get, func_args=[Echo.URI], timeout=180,
                              timeout_message="BP Echo.URI not available after {0}s")

    def calculate_vip_start(self, vip_start, mgmtip, selfip_external):
        if not selfip_external and not vip_start:
            LOG.info('Skipping auto VIP generation.')
            return

        if selfip_external:
            if not isinstance(selfip_external, IPNetwork):
                selfip_external = IPNetwork(selfip_external)

            if selfip_external.prefixlen == 32:
                    LOG.info('Self IP external has no prefix. Assuming /16.')
                    selfip_external.prefixlen = 16

        if vip_start is None:
            # '1.1.1.1/24' -> '1.1.1.0/24'
            cidr = "{0.network}/{0.prefixlen}".format(mgmtip)
            host_id = mgmtip.ip.value - mgmtip.network.value
            subnet_index = SUBNET_MAP.get(cidr)

            if subnet_index is None:
                LOG.warning('The %s subnet was not found! '
                            'Skipping Virtual Servers.' % cidr)
                return

            # Start from 10.11.50.0 - 10.11.147.240 (planned for 10 subnets, 8 VIPs each)
            offset = 1 + 50 * 256 + DEFAULT_VIPS * (256 * subnet_index + host_id)

            vip_start = selfip_external.network + offset
        else:
            vip_start = IPAddress(vip_start)
        return vip_start

    def call(self, *args, **kwargs):
        ret = SCMD.ssh.generic(command=args[0], ifc=self.sshifc)

        if ret and ret.status:
            LOG.warn(ret)
        else:
            LOG.debug(ret)
        return ret

    def is_ha(self):
        ret = self.sshifc.api.run('tmsh show cm sync-status|grep "standalone"')
        return bool(ret.status)

    def is_about_to_expire(self):
        try:
            ret = self.call('tmsh show sys license|grep "License End Date"')
        except SSHCommandError:
            LOG.debug('Unable to find out license expiration date.')
            return False
        exp = datetime.datetime.strptime(ret.stdout.rsplit()[-1], "%Y/%m/%d")
        return exp.date() <= datetime.date.today()

    def license(self, ctx, regkey=None):
        if ctx.status == 'NO LICENSE' and not regkey:
            raise Exception('The box needs to be relicensed first.'
                            'Provide --license <regkey>')

        # Status could be '' in some situations when the license is invalid.
        if regkey and (ctx.status in ['LICENSE INOPERATIVE', 'NO LICENSE', ''] or
                       self.options.get('force_license')):
            LOG.info('Licensing...')
            self.call('SOAPLicenseClient --verbose --basekey %s' % regkey)
            # We need to re-set the modules based on the new license
            tokens = SCMD.ssh.parse_license(ifc=self.sshifc, tokens_only=True)
            ctx.modules = dict([(k[4:], v) for (k, v) in list(tokens.items())
                               if k.startswith('mod_')])

            ctx.features = dict([(k, v) for (k, v) in list(tokens.items())
                                if not k.startswith('mod_')])

            # Tomcat doesn't like the initial licensing through CLI
            if ctx.version.product.is_em:
                ret = self.call('bigstart restart tomcat')
            return True
        if ctx.status in ['LICENSE EXPIRED', 'REACTIVATE LICENSE'] or \
           ctx.status.startswith('LICENSE EXPIRES') or \
                self.is_about_to_expire():
            LOG.info('Re-Licensing...')
            ret = self.call('SOAPLicenseClient --verbose --basekey `grep '
                            '"Registration Key" /config/bigip.license|'
                            'cut -d: -f2`')
            LOG.debug("SOAPLicenseClient returned: %s", ret)
            return True

        return False

    def load_default_config(self):
        ctx = self.context
        if self.can.tmsh(ctx.version):
            LOG.info('Importing default config...')
            self.call('tmsh -q load sys config default')
        else:
            LOG.info('Importing default config...')
            self.call('b import default')

        if ctx.version.product.is_bigiq or ctx.version.product.is_iworkflow:
            if ctx.version >= 'bigiq 5.0':
                self.call('clear-rest-storage')
            else:
                self.call(WIPE_STORAGE)

    def setup(self):
        provider = O()
        if not self.options.no_irack and not self.options.csv:
            LOG.info("Using data from iRack")
            provider = self.irack_provider(address=self.options.irack_address,
                                           username=self.options.irack_username,
                                           apikey=self.options.irack_apikey,
                                           mgmtip=self.address,
                                           timeout=self.options.timeout)
        elif self.options.csv:
            LOG.info("Using data from CSV: %s" % self.options.csv)
            provider = self.csv_provider(mgmtip=self.address)

        ctx = self.make_context()

        # System
        o = O()
        o.partitions = self.options.partitions
        o.nameservers = DNS_SERVERS if self.options.dns_servers is None else \
            self.options.dns_servers
        o.suffixes = DNS_SUFFIXES if self.options.dns_suffixes is None else \
            self.options.dns_suffixes
        o.ntpservers = NTP_SERVERS if self.options.ntp_servers is None else \
            self.options.ntp_servers
        o.smtpserver = 'mail'
        o.hostname = self.options.hostname or provider.get('hostname')
        o.timezone = self.options.timezone
        self.set_networking(o)
        self.set_provisioning(o)
        self.set_users(o)
        if provider.mgmtip and (o.mgmtip.ip != provider.mgmtip.ip or
                                o.mgmtip.cidr != provider.mgmtip.cidr):
            LOG.warning('Management address mismatch. iRack/CSV has {0} but found {1}. iRack/CSV will take precedence.'.format(provider.mgmtip, o.mgmtip))
            o.mgmtip = provider.mgmtip
        mgmtip = o.mgmtip

        if provider.gateway and o.gateway != provider.gateway:
            LOG.warning('Default gateway address mismatch. iRack/CSV has {0} but found {1}. iRack/CSV will take precedence.'.format(provider.gateway, o.gateway))
            o.gateway = provider.gateway
        tree = self.SystemConfig(self.context, **o).run()

        if not self.options.stdout:
            # XXX: Add any given DNS before attempting to relicense.
            # Licensing may need to resolve the license server hostname.
            if self.can.tmsh(ctx.version):
                self.call('tmsh modify sys dns name-servers add { %s }' % ' '.join(o.nameservers))
            if self.license(ctx, self.options.license or provider and provider.licenses.reg_key[0]):
                self.ready_wait()
            if self.options.license_only:
                return

        if self.options.clean or self.is_ha():
            self.load_default_config()
            self.ready_wait()

        if not self.options.stdout:
            self.load(tree, ctx, func=lambda x: not isinstance(x, Partition))
            self.ready_wait()

        if self.options.clean:
            self.reset_trust()
            return

        # Network
        o = O()
        o.tree = tree
        self.set_vlans(o)
        o.selfips = {}
        selfip_internal = self.options.selfip_internal or provider and provider.selfip.internal
        selfip_external = self.options.selfip_external or provider and provider.selfip.external
        if selfip_internal:
            alias = self.options.vlan_internal_name
            o.selfips[alias] = [O(address=selfip_internal)]
            # o.selfips.internal.append(O(address=ip4to6(selfip_internal), name='int_6'))
            o.selfips[alias].append(O(address=ip4to6(selfip_internal)))

        if selfip_external:
            alias = self.options.vlan_external_name
            o.selfips[alias] = [O(address=selfip_external)]
            # o.selfips.external.append(O(address=ip4to6(selfip_external), name='ext_6'))
            o.selfips[alias].append(O(address=ip4to6(selfip_external)))
        tree = self.NetworkConfig(self.context, **o).run()

        # LTM
        o = O(context=self.context)
        o.tree = tree
        o.nodes = self.options.node_count
        o.pools = self.options.pool_count
        o.members = self.options.pool_members
        o.vips = self.options.vip_count
        o.node1 = self.options.node_start
        o.vip1 = self.calculate_vip_start(self.options.vip_start, mgmtip,
                                          selfip_external)
        o.with_monitors = not self.options.no_mon
        tree = self.LTMConfig(**o).run()

        if self.options.stdout:
            self.dump(tree, ctx)
            return

        self.load(tree, ctx)
        self.reset_trust()
        self.ready_wait()
        self.save(ctx)
        self.ssh_key_exchange()
        self.ssl_signedcert_install(o.hostname)
        self.bigiq_special_rest_handling(tree, ctx)
        self.bigip_special_rest_handling(tree, ctx)

    def cleanup(self):
        self.sshifc.close()


def main(*args, **kwargs):
    import optparse
    # import sys

    class OptionWithDefault(optparse.Option):
        strREQUIRED = 'required'
        ATTRS = optparse.Option.ATTRS + [strREQUIRED]

        def __init__(self, *opts, **attrs):
            if attrs.get(self.strREQUIRED, False):
                attrs['help'] = '(Required) ' + attrs.get('help', "")
            optparse.Option.__init__(self, *opts, **attrs)

    class OptionParser(optparse.OptionParser):
        strREQUIRED = 'required'

        def __init__(self, **kwargs):
            kwargs['option_class'] = OptionWithDefault
            optparse.OptionParser.__init__(self, **kwargs)

        def check_values(self, values, args):
            for option in self.option_list:
                if hasattr(option, self.strREQUIRED) and option.required:
                    if not getattr(values, option.dest):
                        self.error("option %s is required" % (str(option)))
            return optparse.OptionParser.check_values(self, values, args)

    def _parser():
        usage = """%prog [options] <address>"""

        formatter = optparse.TitledHelpFormatter(max_help_position=30)
        p = OptionParser(usage=usage,
                         formatter=formatter,
                         version="Config Generator %s" % __version__,
                         )

        p.add_option("", "--partitions", metavar="NUMBER",
                     default=DEFAULT_PARTITIONS, type="int",
                     help="How many partitions. (default: %d)" % DEFAULT_PARTITIONS)
        p.add_option("", "--node-start", metavar="IP", type="string",
                     default=DEFAULT_NODE_START,
                     help="The start address for nodes. (default: %s)" % DEFAULT_NODE_START)
        p.add_option("-n", "--node-count", metavar="NUMBER",
                     default=DEFAULT_NODES, type="int",
                     help="How many nodes. (default: %d)" % DEFAULT_NODES)
        p.add_option("-o", "--pool-count", metavar="NUMBER",
                     default=DEFAULT_POOLS, type="int",
                     help="How many pools. (default: %d)" % DEFAULT_POOLS)
        p.add_option("", "--pool-members", metavar="NUMBER",
                     default=DEFAULT_MEMBERS, type="int",
                     help="How many pool members per pool. (default: %d)" % DEFAULT_MEMBERS)
        p.add_option("", "--vip-start", metavar="IP", type="string",
                     help="The start address for vips. (default: auto)")
        p.add_option("-v", "--vip-count", metavar="NUMBER",
                     default=DEFAULT_VIPS, type="int",
                     help="How many Virtual IPs. (default: %d)" % DEFAULT_VIPS)
        p.add_option("-u", "--username", metavar="STRING",
                     type="string", default=DEFAULT_ROOT_USERNAME,
                     help="SSH root username. (default: %s)" % DEFAULT_ROOT_USERNAME)
        p.add_option("-p", "--password", metavar="STRING",
                     type="string", default=DEFAULT_ROOT_PASSWORD,
                     help="SSH root Password. (default: %s)" % DEFAULT_ROOT_PASSWORD)

        p.add_option("", "--hostname", metavar="HOSTNAME",
                     type="string",
                     help="The device hostname")
        p.add_option("", "--mgmtip", metavar="IP/PREFIX",
                     type="string",
                     help="The device management address")
        p.add_option("", "--mgmtgw", metavar="IP",
                     type="string",
                     help="The device management gateway")
        p.add_option("", "--ssl-port", metavar="INTEGER", type="int", default=443,
                     help="SSL Port. (default: 443)")
        p.add_option("", "--ssh-port", metavar="INTEGER", type="int", default=22,
                     help="SSH Port. (default: 22)")
        p.add_option("", "--selfip-internal", metavar="IP[/PREFIX]",
                     type="string",
                     help="Self IP address for internal vlan.")
        p.add_option("", "--selfip-external", metavar="IP[/PREFIX]",
                     type="string",
                     help="Self IP address for external vlan.")
        p.add_option("", "--vlan-internal", metavar="KEY=VALUE...",
                     type="string",
                     help="Internal VLAN configuration. (e.g 'tag=1111 tagged=1.1 untagged=1.2')")
        p.add_option("", "--vlan-internal-name", metavar="NAME",
                     type="string", default='internal',
                     help="Internal VLAN alternative name.")
        p.add_option("", "--vlan-external", metavar="KEY-VALUE PAIRS",
                     type="string",
                     help="External VLAN configuration. (e.g 'tag=1112 tagged=1.1 untagged=1.2')")
        p.add_option("", "--vlan-external-name", metavar="NAME",
                     type="string", default='external',
                     help="External VLAN alternative name.")
        p.add_option("", "--trunks-lacp",
                     action="store_true",
                     help="Enable LACP on bonth internal and external trunks. (Clusters only)")
        p.add_option("", "--provision", metavar="MODULE:[LEVEL],[MODULE:LEVEL]",
                     type="string",
                     help="Provision module list")
        p.add_option("", "--license", metavar="REGKEY",
                     type="string",
                     help="Set the license")
        p.add_option("", "--force_license", action="store_true", default=False,
                     help="License using a provided reg key. (default: no)")
        p.add_option("", "--timezone", metavar="ZONE",
                     type="string",
                     help="Set the timezone. (e.g. 'America/Los Angeles')")
        p.add_option("", "--dns-server", metavar="IP", dest="dns_servers",
                     type="string", action="append",
                     help="DNS server (multiple OK)")
        p.add_option("", "--dns-suffix", metavar="FQDN", dest="dns_suffixes",
                     type="string", action="append",
                     help="DNS domain search suffix (multiple OK)")
        p.add_option("", "--ntp-server", metavar="FQDN", dest="ntp_servers",
                     type="string", action="append",
                     help="NTP server (multiple OK)")
        p.add_option("", "--license-only",
                     action="store_true",
                     help="Relicense (if needed) and quit.")
        p.add_option("", "--clean",
                     action="store_true",
                     help="Clean vips, pools, nodes on the target")
        p.add_option("", "--verify",
                     action="store_true",
                     help="Verify configuration")

        p.add_option("", "--irack-address", metavar="HOSTNAME",
                     type="string", default="",
                     help="The iRack hostname or IP address")
        p.add_option("", "--irack-username", metavar="STRING",
                     type="string", default="",
                     help="Username used to authenticate with iRack.")
        p.add_option("", "--irack-apikey", metavar="STRING",
                     type="string", default="",
                     help="API key used to authenticate with iRack")

        p.add_option("", "--no-mon",
                     action="store_true",
                     help="Don't set monitors for nodes and pool members. Useful for huge configs.")
        p.add_option("", "--no-sshkey",
                     action="store_true",
                     help="Don't exchange SSH keys.")
        p.add_option("", "--no-irack",
                     action="store_true", default=True,
                     help="Don't attempt to connect to iRack. Useful when network connectivity is not available.")
        p.add_option("", "--csv",
                     type="string", default="",
                     help="Specify the CSV file you want to use. Ex. /config/users/shared/my_file.csv")
        p.add_option("", "--timeout",
                     default=DEFAULT_TIMEOUT, type="int",
                     help="The SSH timeout. (default: %d)" % DEFAULT_TIMEOUT)
        p.add_option("", "--verbose",
                     action="store_true",
                     help="Debug messages")
        p.add_option("", "--stdout",
                     action="store_true",
                     help="Dump configuration to stdout")
        return p

    p = _parser()
    options, args = p.parse_args()

    if not args:
        p.print_version()
        p.print_help()
        sys.exit(2)  # @UndefinedVariable

    m = ConfigPlacer(options, address=args[0])
    m.run()


if __name__ == '__main__':
    main()
